---
layout: sip
title: Inline Definitions and Meta Expressions
---

__Eugene Burmako__
__SÃ©bastien Doeraene__
__Vojin Jovanovic__
__Martin Odersky__
__Dmitry Petrashko__
__Denys Shabalin__

__April 2015__

# Inline Definitions and Meta Expressions

## Motivation ##

## Inline Modifiers

We introduce a new reserved word: `inline`. `inline` can be used as a modifier for:

 - concrete value definitions, e.g.

        inline val x = 4

 - concrete methods, e.g.

        inline def square(x: Double) = x * x

The previous rule of regarding a `final val` with no explicit type as
a compile-time constant (inherited from Java) is dropped. Instead we
write such `val`s now as `inline`.

Value and method definitions labeled `inline` are effectively final;
they cannot be overridden.  Inline members also never override other
members. Instead, every inline member becomes an overloaded alternative
of all other members with the same name. Normal overloading resolution
is applied to pick an inline member over some other member.

If an inline definition doesn't explicitly specify its result type,
the result type gets inferred according to the usual rules.

Inline definitions only exist at compile time; no storage is allocated for them in object layout
and no code is generated for them in object method tables.
That means that it is OK to have an inline member that
has the same type erasure as some other member with the same name.

## Inline Classes

Used as a class modifier, inline makes a class a value class. So

    inline class C(val x: Int)

is equivalent to:

    class C(val x: Int) extends AnyVal

In fact we consider deprecating the second syntax.

Used for an implicit class, inline applies to both the class and the constructor method. So,

    inline implicit class Decorator(val x: T) { ... }

is equivalent to

    inline class Decorator(x: T) { ... }
    inline implicit def Decorator(x: T): Decorator = new Decorator(x)

## Inline Reductions

The compiler will do the following rewritings when encountering certain patterns of code
outside the bodies of inline methods.
When these patterns of code appear inside inline methods,
they will be ignored by the inliner and processed by the compiler as usual.

1. If `prefix.v` refers to an inline value, replace the expression with the value of `v`.

2. If `prefix.f[Ts](args1)...(argsN)` refers to a fully applied inline
method, hoist the prefix and the arguments into temporary variables
and then replace the expression with the method's right-hand side,
where parameter references are replaced by references to temporary variables
created for the corresponding arguments and references to the enclosing `this`
are replaced by references to the temporary variable created for the prefix.

        val x$prefix = prefix
        val x$1 = arg1
        ...
        val x$M = argM
        <f's body with parameter and this references replaced with x$'s>

   This hoisting is intended to preserve the semantics
of method applications under inlining. A method call should have the same
semantics with respect to side effects independently on whether the method was made `inline` or not.
If an inline method has by-name parameters, then corresponding arguments are not hoisted.

   The rewriting is done in accordance with hygiene. Any references from the method
body to its environment will be kept in the rewritten code. If the result of the rewriting
references private/protected definitions in the class that defines the inline method,
these references will be changed to use accessors generated automatically by the compiler.
To ensure that the rewriting works in the separate compilation setting, it is critical
for the compiler to generate the accessors in advance. Most of these accessors can be
pre-generated by analyzing the bodies of inline methods, except for members
that are referred to inside meta scopes. We don't have a good solution for the latter case,
so we will probably disallow such references.

   The rewriting is done in the "outside in" style, i.e. calls to inline methods
are expanded before possible calls to inline methods in their prefixes and arguments.
This is different from how the "inside out" style of macro expansion in Scala 2.10+,
where prefixes and arguments are expanded first. The old style of macro expansion
can, if necessary, be emulated by the new style of inline rewritings.

3. If `prefix.f[Ts](args1)...(argsN)` refers to a partially applied inline
method, an error is raised. Eta expansion of inline methods is prohibited.

## Meta Expressions

A meta expression is an expression of the form

    meta { ... }

where `{ ... }` is some block of Scala code, called meta scope.
(In fact, `meta` may prefix arbitrary expressions, but blocks are expected to be used most commonly).

Meta expressions can appear both in the bodies of inline methods
(then their expansion is going to be deferred until these methods expand) and in normal code
(in that case, expansion will take place immediately at the place where the meta expression is written).

In a meta expression, `meta` is not a keyword, but a reference to a method
declared in the `scala.meta` metaprogramming library:

    def meta[Result](body: implicit scala.meta.semantic.Context => scala.meta.Expr): Result = ???

The `scala.meta.semantic.Context` implicit value defines the reflection API available inside meta scopes,
and `scala.meta.Expr` is one of its members. Full description of the functionality exposed by `scala.meta`
is outside of the scope of this proposal.

Meta expressions can be used with their type arguments omitted, in which case the type argument
is inferred from the expected type. For example, in `inline def async[T](x: T): T = meta { ...; q"..." }`, inference
results in `Result = T`. If a meta expression requires such kind of type inference,
then it is not allowed to use it in the context where an expected type is unspecified,
e.g. omitting the return type `T` of the inline method in the example above is prohibited. In that case,
one could write `inline def async[T](x: T) = meta { ...; q"..." }: T`, making the code valid again.

Meta scopes can only reference the following names in their environment:

 1. type parameters of enclosing inline methods and classes/traits containing an enclosing inline method as a member,
 2. term parameters of enclosing inline methods,
 3. `this` references to classes/traits containing an enclosing inline method as a member,
 4. inline values,
 5. inline methods,
 6. anything that's global (i.e. a class/trait/object without an outer reference).

Names referenced in meta scopes undergo the following transformation:

 1. Names that reference global definitions (terms or types) are left untouched.
 2. Names that reference inline members are left untouched as well.
 3. Names that reference local term definitions or `this` change their type to `scala.meta.Expr`.
 4. Names that reference local type definitions become term references of type `scala.meta.Type`.

In other words, definitions that are statically available outside meta scopes remain available in meta scopes,
term and type arguments of enclosing inline methods become available as their representations,
and inline values and methods change their type by having `inline` annotations inverted.

As a consequence of how inline reductions work, by-value term parameters of encloding inline methods
will be passed to macro scopes as trees representing references to temporary variables generated to
respect by-value semantics. In order for a macro scope to get access to representations of
actual arguments of an enclosing inline method, corresponding parameters need to be declared as by-name,
e.g. `inline def async[T](x: => T): T = meta { ... }`. A representation of a `this` reference always
follows the by-value scheme, and in order to obtain an actual prefix of an enclosing inline application,
one should use the functionality of `scala.meta.semantic.Context`.

## Meta Expansion

During typechecking, the compiler treats meta expressions, i.e. invocations of the `meta` method,
as normal method calls, typechecking the arguments of those calls (i.e. meta scopes), and
performing type inference if necessary, but nothing else.
In this proposal, meta expansion works differently from macro expansion in Scala 2.10+,
where macro applications are expanded immediately after being processed by the typechecker.

An important consequence is that meta expressions cannot refine their types during expansion.
This makes it impossible to use the proposed metaprogramming system to implement
[whitebox macros](http://docs.scala-lang.org/overviews/macros/blackbox-whitebox.html) from Scala 2.10+,
but we are planning to eventually provide alternative ways of enabling the most important whitebox functionality.

At some point in the compilation pipeline, after typechecking is complete for the entirety of the program,
the compiler expands meta expressions outside the bodies of inline methods.
When meta expressions appear inside inline methods,
they will be ignored by the meta expander and processed by the compiler as usual.

A meta expression is expanded by evaluating its body and replacing the original meta expression
with an expression that represents the result of the evaluation.
The implementation is responsible for instantiating a `scala.meta.semantic.Context` necessary for meta scopes
to evaluate and for converting between its internal representation for program elements and representations
defined in `scala.meta`, such as `scala.meta.Expr` and `scala.meta.Type`.
